<?php
/**
 * Copyright Â© Magento. All rights reserved.
 * See COPYING.txt for license details.
 */

namespace Magento2\Sniffs\PHP;

use PHP_CodeSniffer\Files\File;
use PHP_CodeSniffer\Sniffs\Sniff;

/**
 * Detects possible usage of 'var' language construction.
 */
class AutogeneratedClassNotInConstructorSniff implements Sniff
{
    const ERROR_CODE = 'AUTOGENERATED_CLASS_NOT_IN_CONSTRUCTOR';
    /**
     * @var mixed
     */
    private $constructorScopeOpener;
    /**
     * @var mixed
     */
    private $constructorScopeCloser;

    /**
     * @var array
     */
    private $constructorParameters = [];

    /**
     * @var array
     */
    private $uses = [];

    /**
     * @inheritdoc
     */
    public function register()
    {
        return [T_FUNCTION, T_DOUBLE_COLON, T_USE];
    }

    /**
     * @inheritdoc
     */
    public function process(File $phpcsFile, $stackPtr)
    {
        if ($phpcsFile->getTokens()[$stackPtr]['type'] === 'T_USE') {
            $this->registerUses($phpcsFile, $stackPtr);
        }
        if ($phpcsFile->getTokens()[$stackPtr]['type'] === 'T_FUNCTION') {
            $this->registerConstructorParameters($phpcsFile, $stackPtr);
        }
        if ($phpcsFile->getTokens()[$stackPtr]['type'] === 'T_DOUBLE_COLON') {
            if (!$this->isInsideConstruct($stackPtr)) {
                return;
            }
            if (!$this->isObjectManagerGetInstance($phpcsFile, $stackPtr)) {
                return;
            }

            $statementStart = $phpcsFile->findStartOfStatement($stackPtr);
            $statementEnd = $phpcsFile->findEndOfStatement($stackPtr);
            $equalsPtr = $phpcsFile->findNext(T_EQUAL, $statementStart, $statementEnd);

            if (!$equalsPtr) {
                return;
            }

            $variableInParameters = false;
            if ($variable = $phpcsFile->findNext(T_VARIABLE, $equalsPtr, $statementEnd)) {
                $variableName = $phpcsFile->getTokens()[$variable]['content'];
                foreach ($this->constructorParameters as $parameter) {
                    $parameterName = $parameter['name'];
                    if ($parameterName === $variableName) {
                        $variableInParameters = true;
                    }
                }
            }

            if (!$variableInParameters) {
                $next = $stackPtr;
                while ($next = $phpcsFile->findNext(T_DOUBLE_COLON, $next + 1, $statementEnd)) {
                    if ($this->getNext($phpcsFile, $next, $statementEnd, T_STRING)['content'] === 'class') {
                        $className = $this->getPrevious($phpcsFile, $next, T_STRING)['content'];
                    }
                }

                $className = $this->getClassNamespace($className);

                $phpcsFile->addError(
                    sprintf("Class %s needs to be requested in constructor, " .
                        "otherwise compiler will not be able to find and generate these classes", $className),
                    $stackPtr,
                    self::ERROR_CODE
                );
            }
        }
    }

    /**
     * Check if it is a ObjectManager::getInstance
     *
     * @param File $phpcsFile
     * @param int $stackPtr
     * @return bool
     */
    private function isObjectManagerGetInstance(File $phpcsFile, int $stackPtr): bool
    {
        $prev = $phpcsFile->findPrevious(T_STRING, $stackPtr - 1);
        $next = $phpcsFile->findNext(T_STRING, $stackPtr + 1);
        if ($prev &&
            $next &&
            $phpcsFile->getTokens()[$prev]['content'] === 'ObjectManager' &&
            $phpcsFile->getTokens()[$next]['content'] === 'getInstance') {
            return true;
        }
        return false;
    }

    /**
     * Checks if the code is inside __construct
     *
     * @param int $stackPtr
     * @return bool
     */
    private function isInsideConstruct(int $stackPtr): bool
    {
        return $stackPtr > $this->constructorScopeOpener && $stackPtr < $this->constructorScopeCloser;
    }

    /**
     * Get the complete class namespace from the use's
     *
     * @param string $className
     * @return string
     */
    private function getClassNamespace(string $className): string
    {
        foreach ($this->uses as $use) {
            if (end($use) === $className) {
                $className = implode('/', $use);
            }
        }
        return $className;
    }

    /**
     * Register php uses
     *
     * @param File $phpcsFile
     * @param int $stackPtr
     */
    private function registerUses(File $phpcsFile, int $stackPtr): void
    {
        $useEnd = $phpcsFile->findEndOfStatement($stackPtr);
        $use = [];
        $usePosition = $stackPtr;
        while ($usePosition = $phpcsFile->findNext(T_STRING, $usePosition + 1, $useEnd)) {
            $use[] = $phpcsFile->getTokens()[$usePosition]['content'];
        }
        $this->uses [] = $use;
    }

    /**
     * Register php constructor parameters
     *
     * @param File $phpcsFile
     * @param int $stackPtr
     */
    private function registerConstructorParameters(File $phpcsFile, int $stackPtr): void
    {
        $functionName = $phpcsFile->getDeclarationName($stackPtr);
        if ($functionName == '__construct') {
            $this->constructorParameters = $phpcsFile->getMethodParameters($stackPtr);
            $this->constructorScopeOpener = $phpcsFile->getTokens()[$stackPtr]['scope_opener'];
            $this->constructorScopeCloser = $phpcsFile->getTokens()[$stackPtr]['scope_closer'];

        }
    }

    /**
     * Get next token
     *
     * @param File $phpcsFile
     * @param int $nextDoubleColumn
     * @param int $statementEnd
     * @param int|string|array $types
     * @return mixed
     */
    private function getNext(File $phpcsFile, int $nextDoubleColumn, int $statementEnd, $types)
    {
        return $phpcsFile->getTokens()[$phpcsFile->findNext($types, $nextDoubleColumn + 1, $statementEnd)];
    }

    /**
     * Get previous token
     *
     * @param File $phpcsFile
     * @param int $nextDoubleColumn
     * @param int|string|array $types
     * @return mixed
     */
    private function getPrevious(File $phpcsFile, int $nextDoubleColumn, $types)
    {
        return $phpcsFile->getTokens()[$phpcsFile->findPrevious($types, $nextDoubleColumn - 1)];
    }
}
